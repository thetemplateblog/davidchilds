---
id: cicd-optimization-2025
blueprint: writing
title: 'Migrate from Jenkins to GitHub Actions'
author: 443cb49f-b30a-4e19-8c4a-fc72691de37d
updated_by: 443cb49f-b30a-4e19-8c4a-fc72691de37d
updated_at: 1754953349
categories:
  - devops
intro: 'Learn how to modernize your CI/CD pipeline by migrating from Jenkins to GitHub Actions, with real-world examples and performance comparisons.'
---

After maintaining Jenkins pipelines for years, I recently led a migration to GitHub Actions that reduced our build times by 60% and cut our CI/CD maintenance overhead in half. Here's how we did it and what we learned.

## Why Consider Migration?

Jenkins served us well, but we faced growing challenges:
- **Maintenance overhead**: Constant plugin updates and security patches
- **Scaling issues**: Managing build agents became complex
- **Integration friction**: Extra steps for GitHub integration
- **Cost**: Dedicated infrastructure for Jenkins masters and agents

## Migration Strategy

### Phase 1: Assessment and Planning

First, audit your existing pipelines:
```groovy
// Typical Jenkinsfile structure
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'npm install'
                sh 'npm run build'
            }
        }
        stage('Test') {
            steps {
                sh 'npm test'
            }
        }
        stage('Deploy') {
            steps {
                sh './deploy.sh'
            }
        }
    }
}
```

### Phase 2: Equivalent GitHub Actions Workflow

Transform to GitHub Actions:
```yaml
name: CI/CD Pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run build
      - run: npm test
      
  deploy:
    needs: build-and-test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: ./deploy.sh
```

## Key Migration Patterns

### 1. Environment Variables and Secrets

**Jenkins:**
```groovy
environment {
    API_KEY = credentials('api-key')
    DB_PASSWORD = credentials('db-password')
}
```

**GitHub Actions:**
```yaml
env:
  API_KEY: ${{ secrets.API_KEY }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
```

### 2. Parallel Execution

**Jenkins:**
```groovy
parallel {
    stage('Unit Tests') {
        steps { sh 'npm run test:unit' }
    }
    stage('Integration Tests') {
        steps { sh 'npm run test:integration' }
    }
}
```

**GitHub Actions:**
```yaml
jobs:
  test:
    strategy:
      matrix:
        test-type: [unit, integration]
    runs-on: ubuntu-latest
    steps:
      - run: npm run test:${{ matrix.test-type }}
```

### 3. Conditional Execution

**Jenkins:**
```groovy
stage('Deploy') {
    when {
        branch 'main'
    }
    steps {
        sh './deploy.sh'
    }
}
```

**GitHub Actions:**
```yaml
- name: Deploy
  if: github.ref == 'refs/heads/main'
  run: ./deploy.sh
```

## Advanced Features Comparison

### Matrix Builds
GitHub Actions excels at matrix builds:
```yaml
strategy:
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    node: [14, 16, 18]
    exclude:
      - os: windows-latest
        node: 14
```

### Reusable Workflows
Create modular, reusable components:
```yaml
# .github/workflows/reusable-build.yml
on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string

jobs:
  build:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    steps:
      - run: echo "Building for ${{ inputs.environment }}"
```

### Self-Hosted Runners
For specialized requirements:
```yaml
runs-on: [self-hosted, linux, x64, gpu]
```

## Performance Optimization

### 1. Caching Dependencies
```yaml
- uses: actions/cache@v3
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-
```

### 2. Artifact Management
```yaml
- uses: actions/upload-artifact@v3
  with:
    name: build-output
    path: dist/
    retention-days: 5
```

### 3. Concurrent Job Limits
```yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
```

## Cost Comparison

### Jenkins (Self-Hosted)
- EC2 instances: ~$200/month
- Maintenance time: ~20 hours/month
- Plugin licensing: Variable

### GitHub Actions
- Free tier: 2,000 minutes/month
- Additional minutes: $0.008/minute (Linux)
- Self-hosted runners: Free

## Migration Challenges and Solutions

### Challenge 1: Complex Build Scripts
**Solution**: Containerize build environments
```yaml
container:
  image: custom-build-image:latest
  credentials:
    username: ${{ github.actor }}
    password: ${{ secrets.github_token }}
```

### Challenge 2: Jenkins-Specific Plugins
**Solution**: Find GitHub Actions marketplace alternatives or create composite actions

### Challenge 3: Historical Build Data
**Solution**: Export Jenkins build history to external storage before migration

## Monitoring and Observability

### GitHub Actions Insights
- Built-in workflow run history
- Detailed timing breakdowns
- Automatic failure notifications

### Custom Metrics
```yaml
- name: Report Metrics
  uses: ./.github/actions/metrics
  with:
    datadog-api-key: ${{ secrets.DATADOG_API_KEY }}
    metric-name: 'pipeline.duration'
    metric-value: ${{ steps.build.outputs.duration }}
```

## Security Improvements

### OIDC for Cloud Providers
```yaml
- uses: aws-actions/configure-aws-credentials@v2
  with:
    role-to-assume: arn:aws:iam::123456789:role/github-actions
    aws-region: us-east-1
```

### Dependency Scanning
```yaml
- name: Security Scan
  uses: github/super-linter@v4
  env:
    DEFAULT_BRANCH: main
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## Rollback Strategy

Keep Jenkins running in parallel during migration:
1. Duplicate pipelines in both systems
2. Compare results for consistency
3. Gradually shift traffic to GitHub Actions
4. Decommission Jenkins after validation period

## Results After Migration

- **Build time**: Reduced from 15 minutes to 6 minutes
- **Maintenance**: From 20 hours/month to 2 hours/month
- **Cost**: 40% reduction in CI/CD expenses
- **Developer satisfaction**: Increased due to better GitHub integration

## Conclusion

Migrating from Jenkins to GitHub Actions isn't just about modernization â€“ it's about improving developer productivity and reducing operational overhead. While Jenkins remains powerful for complex scenarios, GitHub Actions offers superior integration, lower maintenance, and better cost efficiency for most teams.

Start with non-critical pipelines, learn the patterns, and gradually migrate your entire CI/CD infrastructure. The investment in migration pays off quickly through reduced maintenance and improved developer experience.