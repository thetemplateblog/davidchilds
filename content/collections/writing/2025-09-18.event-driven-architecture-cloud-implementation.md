---
id: event-driven-architecture-3
blueprint: writing
title: 'Event-Driven Architecture in the Cloud'
author: 443cb49f-b30a-4e19-8c4a-fc72691de37d
categories:
  - cloud
intro: 'Build scalable, resilient event-driven systems in the cloud with comprehensive patterns, implementations, and best practices. Learn event sourcing, CQRS,...'
---

# Event-Driven Architecture in the Cloud: Complete Implementation Guide

Event-driven architecture (EDA) has become essential for building scalable, loosely coupled systems in the cloud. This comprehensive guide explores advanced event-driven patterns, cloud-native implementations, and production-ready strategies for building resilient distributed systems that can handle millions of events per second.

## Understanding Event-Driven Architecture

### Core Concepts

Event-driven architecture is a software design paradigm where services communicate by producing and consuming events. Events represent state changes or significant occurrences in the system, enabling loose coupling and high scalability.

**Key Components:**
- **Event Producers**: Services that generate events
- **Event Brokers**: Infrastructure that routes events
- **Event Consumers**: Services that process events
- **Event Store**: Persistent storage for events
- **Event Schemas**: Contracts defining event structure

### Benefits of Event-Driven Systems

1. **Loose Coupling**: Services don't need direct knowledge of each other
2. **High Scalability**: Asynchronous processing enables independent scaling
3. **Resilience**: Fault tolerance through message persistence and replay
4. **Real-time Processing**: Immediate response to business events
5. **Auditability**: Complete event history for compliance and debugging

## Event Sourcing Pattern Implementation

### Core Event Sourcing Infrastructure

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, Type
from dataclasses import dataclass, field
from datetime import datetime
import json
import uuid
from enum import Enum

@dataclass
class DomainEvent:
    """Base class for all domain events"""
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    event_type: str = ""
    aggregate_id: str = ""
    aggregate_type: str = ""
    event_version: int = 1
    timestamp: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)
    data: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'event_id': self.event_id,
            'event_type': self.event_type,
            'aggregate_id': self.aggregate_id,
            'aggregate_type': self.aggregate_type,
            'event_version': self.event_version,
            'timestamp': self.timestamp.isoformat(),
            'metadata': self.metadata,
            'data': self.data
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DomainEvent':
        return cls(
            event_id=data['event_id'],
            event_type=data['event_type'],
            aggregate_id=data['aggregate_id'],
            aggregate_type=data['aggregate_type'],
            event_version=data['event_version'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            metadata=data.get('metadata', {}),
            data=data.get('data', {})
        )

# Specific domain events
@dataclass
class UserRegisteredEvent(DomainEvent):
    def __init__(self, user_id: str, email: str, name: str, **kwargs):
        super().__init__(
            event_type="UserRegistered",
            aggregate_id=user_id,
            aggregate_type="User",
            data={
                'user_id': user_id,
                'email': email,
                'name': name,
                **kwargs
            }
        )

@dataclass
class OrderCreatedEvent(DomainEvent):
    def __init__(self, order_id: str, customer_id: str, items: List[Dict], total: float):
        super().__init__(
            event_type="OrderCreated",
            aggregate_id=order_id,
            aggregate_type="Order",
            data={
                'order_id': order_id,
                'customer_id': customer_id,
                'items': items,
                'total': total,
                'status': 'pending'
            }
        )

@dataclass
class PaymentProcessedEvent(DomainEvent):
    def __init__(self, payment_id: str, order_id: str, amount: float, status: str):
        super().__init__(
            event_type="PaymentProcessed",
            aggregate_id=payment_id,
            aggregate_type="Payment",
            data={
                'payment_id': payment_id,
                'order_id': order_id,
                'amount': amount,
                'status': status,
                'processed_at': datetime.utcnow().isoformat()
            }
        )

# Event Store Interface
class EventStore(ABC):
    @abstractmethod
    async def save_events(self, events: List[DomainEvent], expected_version: int) -> None:
        pass
    
    @abstractmethod
    async def get_events(self, aggregate_id: str, from_version: int = 0) -> List[DomainEvent]:
        pass
    
    @abstractmethod
    async def get_all_events(self, from_timestamp: Optional[datetime] = None) -> List[DomainEvent]:
        pass

# DynamoDB Event Store Implementation
import boto3
from boto3.dynamodb.conditions import Key
from botocore.exceptions import ClientError

class DynamoDBEventStore(EventStore):
    def __init__(self, table_name: str = 'event_store'):
        self.dynamodb = boto3.resource('dynamodb')
        self.table = self.dynamodb.Table(table_name)
    
    async def save_events(self, events: List[DomainEvent], expected_version: int) -> None:
        """Save events with optimistic concurrency control"""
        
        if not events:
            return
        
        aggregate_id = events[0].aggregate_id
        
        # Batch write events
        with self.table.batch_writer() as batch:
            for i, event in enumerate(events):
                version = expected_version + i + 1
                
                item = {
                    'aggregate_id': aggregate_id,
                    'version': version,
                    'event_id': event.event_id,
                    'event_type': event.event_type,
                    'aggregate_type': event.aggregate_type,
                    'timestamp': event.timestamp.isoformat(),
                    'data': json.dumps(event.data),
                    'metadata': json.dumps(event.metadata),
                    'global_sequence': int(event.timestamp.timestamp() * 1000000)
                }
                
                try:
                    batch.put_item(
                        Item=item,
                        ConditionExpression='attribute_not_exists(aggregate_id) AND attribute_not_exists(version)'
                    )
                except ClientError as e:
                    if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
                        raise ConcurrencyError(f"Concurrency conflict for aggregate {aggregate_id}")
                    raise
    
    async def get_events(self, aggregate_id: str, from_version: int = 0) -> List[DomainEvent]:
        """Get events for specific aggregate"""
        
        try:
            response = self.table.query(
                KeyConditionExpression=Key('aggregate_id').eq(aggregate_id) & Key('version').gte(from_version),
                ScanIndexForward=True  # Sort ascending by version
            )
            
            events = []
            for item in response['Items']:
                event = DomainEvent(
                    event_id=item['event_id'],
                    event_type=item['event_type'],
                    aggregate_id=item['aggregate_id'],
                    aggregate_type=item['aggregate_type'],
                    event_version=item['version'],
                    timestamp=datetime.fromisoformat(item['timestamp']),
                    data=json.loads(item['data']),
                    metadata=json.loads(item['metadata'])
                )
                events.append(event)
            
            return events
            
        except Exception as e:
            raise Exception(f"Failed to get events for aggregate {aggregate_id}: {str(e)}")
    
    async def get_all_events(self, from_timestamp: Optional[datetime] = None) -> List[DomainEvent]:
        """Get all events for event replay/projection"""
        
        try:
            scan_kwargs = {}
            if from_timestamp:
                global_sequence = int(from_timestamp.timestamp() * 1000000)
                scan_kwargs['FilterExpression'] = Key('global_sequence').gte(global_sequence)
            
            response = self.table.scan(**scan_kwargs)
            
            # Sort by global sequence to maintain order
            items = sorted(response['Items'], key=lambda x: x['global_sequence'])
            
            events = []
            for item in items:
                event = DomainEvent(
                    event_id=item['event_id'],
                    event_type=item['event_type'],
                    aggregate_id=item['aggregate_id'],
                    aggregate_type=item['aggregate_type'],
                    event_version=item['version'],
                    timestamp=datetime.fromisoformat(item['timestamp']),
                    data=json.loads(item['data']),
                    metadata=json.loads(item['metadata'])
                )
                events.append(event)
            
            return events
            
        except Exception as e:
            raise Exception(f"Failed to get all events: {str(e)}")

class ConcurrencyError(Exception):
    pass

# Aggregate Root Base Class
class AggregateRoot:
    def __init__(self, aggregate_id: str):
        self.aggregate_id = aggregate_id
        self.version = 0
        self.uncommitted_events: List[DomainEvent] = []
    
    def apply_event(self, event: DomainEvent):
        """Apply event to aggregate state"""
        handler_name = f"_handle_{event.event_type}"
        handler = getattr(self, handler_name, None)
        
        if handler:
            handler(event)
        
        self.version += 1
    
    def raise_event(self, event: DomainEvent):
        """Raise new event"""
        self.uncommitted_events.append(event)
        self.apply_event(event)
    
    def mark_events_as_committed(self):
        """Mark events as committed after saving to store"""
        self.uncommitted_events.clear()

# Order Aggregate Example
class Order(AggregateRoot):
    def __init__(self, order_id: str):
        super().__init__(order_id)
        self.customer_id = ""
        self.items = []
        self.total = 0.0
        self.status = "draft"
        self.payment_id = None
    
    @classmethod
    def create_order(cls, order_id: str, customer_id: str, items: List[Dict], total: float) -> 'Order':
        """Factory method to create new order"""
        order = cls(order_id)
        
        # Validate order data
        if not items:
            raise ValueError("Order must have at least one item")
        if total <= 0:
            raise ValueError("Order total must be positive")
        
        # Raise domain event
        event = OrderCreatedEvent(order_id, customer_id, items, total)
        order.raise_event(event)
        
        return order
    
    def process_payment(self, payment_id: str, amount: float, status: str):
        """Process payment for order"""
        if self.status != "pending":
            raise ValueError(f"Cannot process payment for order in {self.status} status")
        
        event = PaymentProcessedEvent(payment_id, self.aggregate_id, amount, status)
        self.raise_event(event)
    
    def _handle_OrderCreated(self, event: DomainEvent):
        """Handle OrderCreated event"""
        self.customer_id = event.data['customer_id']
        self.items = event.data['items']
        self.total = event.data['total']
        self.status = "pending"
    
    def _handle_PaymentProcessed(self, event: DomainEvent):
        """Handle PaymentProcessed event"""
        self.payment_id = event.data['payment_id']
        
        if event.data['status'] == 'success':
            self.status = "confirmed"
        elif event.data['status'] == 'failed':
            self.status = "payment_failed"

# Repository Pattern for Aggregates
class OrderRepository:
    def __init__(self, event_store: EventStore):
        self.event_store = event_store
    
    async def save(self, order: Order) -> None:
        """Save aggregate by storing its uncommitted events"""
        if order.uncommitted_events:
            await self.event_store.save_events(
                order.uncommitted_events,
                order.version - len(order.uncommitted_events)
            )
            order.mark_events_as_committed()
    
    async def get_by_id(self, order_id: str) -> Optional[Order]:
        """Reconstruct aggregate from events"""
        events = await self.event_store.get_events(order_id)
        
        if not events:
            return None
        
        order = Order(order_id)
        
        for event in events:
            order.apply_event(event)
        
        return order
```

### Cloud Message Broker Integration

```python
# AWS SNS/SQS Event Bus Implementation
import boto3
import json
from typing import Callable, Dict, Any, List
import asyncio
from concurrent.futures import ThreadPoolExecutor

class AWSEventBus:
    def __init__(self, region_name: str = 'us-east-1'):
        self.sns = boto3.client('sns', region_name=region_name)
        self.sqs = boto3.client('sqs', region_name=region_name)
        self.topic_arns = {}
        self.queue_urls = {}
        self.subscribers = {}
        self.executor = ThreadPoolExecutor(max_workers=10)
    
    async def create_topic(self, topic_name: str) -> str:
        """Create SNS topic"""
        try:
            response = self.sns.create_topic(Name=topic_name)
            topic_arn = response['TopicArn']
            self.topic_arns[topic_name] = topic_arn
            return topic_arn
        except Exception as e:
            raise Exception(f"Failed to create topic {topic_name}: {str(e)}")
    
    async def create_queue(self, queue_name: str, dead_letter_queue: bool = True) -> str:
        """Create SQS queue with optional DLQ"""
        try:
            # Create dead letter queue first if requested
            dlq_arn = None
            if dead_letter_queue:
                dlq_response = self.sqs.create_queue(
                    QueueName=f"{queue_name}-dlq",
                    Attributes={
                        'MessageRetentionPeriod': '1209600',  # 14 days
                        'VisibilityTimeoutSeconds': '300'
                    }
                )
                dlq_url = dlq_response['QueueUrl']
                dlq_attrs = self.sqs.get_queue_attributes(
                    QueueUrl=dlq_url,
                    AttributeNames=['QueueArn']
                )
                dlq_arn = dlq_attrs['Attributes']['QueueArn']
            
            # Create main queue
            queue_attributes = {
                'MessageRetentionPeriod': '1209600',  # 14 days
                'VisibilityTimeoutSeconds': '300',
                'DelaySeconds': '0'
            }
            
            if dlq_arn:
                queue_attributes['RedrivePolicy'] = json.dumps({
                    'deadLetterTargetArn': dlq_arn,
                    'maxReceiveCount': 3
                })
            
            response = self.sqs.create_queue(
                QueueName=queue_name,
                Attributes=queue_attributes
            )
            
            queue_url = response['QueueUrl']
            self.queue_urls[queue_name] = queue_url
            return queue_url
            
        except Exception as e:
            raise Exception(f"Failed to create queue {queue_name}: {str(e)}")
    
    async def subscribe_queue_to_topic(self, topic_name: str, queue_name: str, 
                                     filter_policy: Dict[str, Any] = None) -> None:
        """Subscribe SQS queue to SNS topic"""
        try:
            topic_arn = self.topic_arns.get(topic_name)
            queue_url = self.queue_urls.get(queue_name)
            
            if not topic_arn or not queue_url:
                raise ValueError("Topic or queue not found")
            
            # Get queue ARN
            queue_attrs = self.sqs.get_queue_attributes(
                QueueUrl=queue_url,
                AttributeNames=['QueueArn']
            )
            queue_arn = queue_attrs['Attributes']['QueueArn']
            
            # Subscribe queue to topic
            subscription_attrs = {}
            if filter_policy:
                subscription_attrs['FilterPolicy'] = json.dumps(filter_policy)
            
            response = self.sns.subscribe(
                TopicArn=topic_arn,
                Protocol='sqs',
                Endpoint=queue_arn,
                Attributes=subscription_attrs
            )
            
            # Allow SNS to write to SQS
            policy = {
                "Version": "2012-10-17",
                "Statement": [{
                    "Effect": "Allow",
                    "Principal": {"Service": "sns.amazonaws.com"},
                    "Action": "sqs:SendMessage",
                    "Resource": queue_arn,
                    "Condition": {
                        "ArnEquals": {
                            "aws:SourceArn": topic_arn
                        }
                    }
                }]
            }
            
            self.sqs.set_queue_attributes(
                QueueUrl=queue_url,
                Attributes={'Policy': json.dumps(policy)}
            )
            
            return response['SubscriptionArn']
            
        except Exception as e:
            raise Exception(f"Failed to subscribe queue to topic: {str(e)}")
    
    async def publish_event(self, topic_name: str, event: DomainEvent, 
                          message_attributes: Dict[str, Any] = None) -> str:
        """Publish event to SNS topic"""
        try:
            topic_arn = self.topic_arns.get(topic_name)
            if not topic_arn:
                raise ValueError(f"Topic {topic_name} not found")
            
            message = json.dumps(event.to_dict())
            
            # Prepare message attributes for filtering
            sns_attributes = {
                'event_type': {
                    'DataType': 'String',
                    'StringValue': event.event_type
                },
                'aggregate_type': {
                    'DataType': 'String',
                    'StringValue': event.aggregate_type
                }
            }
            
            if message_attributes:
                for key, value in message_attributes.items():
                    sns_attributes[key] = {
                        'DataType': 'String',
                        'StringValue': str(value)
                    }
            
            response = self.sns.publish(
                TopicArn=topic_arn,
                Message=message,
                Subject=f"{event.event_type} - {event.aggregate_id}",
                MessageAttributes=sns_attributes
            )
            
            return response['MessageId']
            
        except Exception as e:
            raise Exception(f"Failed to publish event: {str(e)}")
    
    def register_handler(self, queue_name: str, handler: Callable[[DomainEvent], None]):
        """Register event handler for queue"""
        self.subscribers[queue_name] = handler
    
    async def start_consuming(self, queue_name: str, max_messages: int = 10):
        """Start consuming messages from queue"""
        queue_url = self.queue_urls.get(queue_name)
        handler = self.subscribers.get(queue_name)
        
        if not queue_url or not handler:
            raise ValueError(f"Queue {queue_name} or handler not found")
        
        while True:
            try:
                # Poll for messages
                response = self.sqs.receive_message(
                    QueueUrl=queue_url,
                    MaxNumberOfMessages=max_messages,
                    WaitTimeSeconds=20,  # Long polling
                    MessageAttributeNames=['All']
                )
                
                messages = response.get('Messages', [])
                
                # Process messages concurrently
                tasks = []
                for message in messages:
                    task = asyncio.create_task(
                        self._process_message(queue_url, message, handler)
                    )
                    tasks.append(task)
                
                if tasks:
                    await asyncio.gather(*tasks, return_exceptions=True)
                
            except Exception as e:
                print(f"Error consuming from {queue_name}: {str(e)}")
                await asyncio.sleep(5)  # Wait before retrying
    
    async def _process_message(self, queue_url: str, message: Dict[str, Any], 
                             handler: Callable[[DomainEvent], None]):
        """Process individual message"""
        try:
            # Parse SNS message
            body = json.loads(message['Body'])
            
            if 'Message' in body:
                # SNS message wrapped in SQS
                event_data = json.loads(body['Message'])
            else:
                # Direct SQS message
                event_data = body
            
            # Create domain event
            event = DomainEvent.from_dict(event_data)
            
            # Execute handler in thread pool to avoid blocking
            await asyncio.get_event_loop().run_in_executor(
                self.executor, handler, event
            )
            
            # Delete message from queue after successful processing
            self.sqs.delete_message(
                QueueUrl=queue_url,
                ReceiptHandle=message['ReceiptHandle']
            )
            
        except Exception as e:
            print(f"Failed to process message: {str(e)}")
            # Message will become visible again after visibility timeout

# Event Handlers
class EventHandlers:
    def __init__(self):
        self.email_service = EmailService()
        self.inventory_service = InventoryService()
        self.analytics_service = AnalyticsService()
    
    async def handle_user_registered(self, event: DomainEvent):
        """Handle user registration events"""
        user_data = event.data
        
        try:
            # Send welcome email
            await self.email_service.send_welcome_email(
                user_data['email'],
                user_data['name']
            )
            
            # Track user registration in analytics
            await self.analytics_service.track_event(
                'user_registered',
                user_data['user_id'],
                {
                    'registration_source': event.metadata.get('source', 'unknown'),
                    'timestamp': event.timestamp.isoformat()
                }
            )
            
            print(f"Processed user registration for {user_data['email']}")
            
        except Exception as e:
            print(f"Failed to handle user registration: {str(e)}")
            raise
    
    async def handle_order_created(self, event: DomainEvent):
        """Handle order creation events"""
        order_data = event.data
        
        try:
            # Reserve inventory
            reservation_result = await self.inventory_service.reserve_items(
                order_data['items']
            )
            
            if not reservation_result['success']:
                # Publish inventory reservation failed event
                failed_event = DomainEvent(
                    event_type="InventoryReservationFailed",
                    aggregate_id=order_data['order_id'],
                    aggregate_type="Order",
                    data={
                        'order_id': order_data['order_id'],
                        'reason': reservation_result['reason'],
                        'failed_items': reservation_result['failed_items']
                    }
                )
                
                # This would be published back to the event bus
                print(f"Inventory reservation failed for order {order_data['order_id']}")
                return
            
            # Track order creation
            await self.analytics_service.track_event(
                'order_created',
                order_data['customer_id'],
                {
                    'order_id': order_data['order_id'],
                    'total': order_data['total'],
                    'item_count': len(order_data['items'])
                }
            )
            
            print(f"Processed order creation {order_data['order_id']}")
            
        except Exception as e:
            print(f"Failed to handle order creation: {str(e)}")
            raise
    
    async def handle_payment_processed(self, event: DomainEvent):
        """Handle payment processing events"""
        payment_data = event.data
        
        try:
            if payment_data['status'] == 'success':
                # Send order confirmation email
                # Update order status
                # Trigger fulfillment process
                print(f"Payment successful for order {payment_data['order_id']}")
            else:
                # Handle payment failure
                # Notify customer
                # Release inventory
                print(f"Payment failed for order {payment_data['order_id']}")
            
        except Exception as e:
            print(f"Failed to handle payment processing: {str(e)}")
            raise

# Service implementations (simplified for example)
class EmailService:
    async def send_welcome_email(self, email: str, name: str):
        print(f"Sending welcome email to {email}")
        # Implementation would use AWS SES, SendGrid, etc.

class InventoryService:
    async def reserve_items(self, items: List[Dict]) -> Dict[str, Any]:
        print(f"Reserving inventory for {len(items)} items")
        # Implementation would check and reserve inventory
        return {'success': True, 'reservation_id': str(uuid.uuid4())}

class AnalyticsService:
    async def track_event(self, event_type: str, user_id: str, properties: Dict[str, Any]):
        print(f"Tracking {event_type} for user {user_id}")
        # Implementation would send to analytics platform
```

### CQRS with Event Sourcing

```python
# Command and Query separation with event sourcing
from abc import ABC, abstractmethod
from typing import Generic, TypeVar, Optional

T = TypeVar('T')

class Command(ABC):
    pass

class Query(Generic[T], ABC):
    pass

class CommandHandler(ABC):
    @abstractmethod
    async def handle(self, command: Command) -> None:
        pass

class QueryHandler(Generic[T], ABC):
    @abstractmethod
    async def handle(self, query: Query[T]) -> T:
        pass

# Commands
class CreateOrderCommand(Command):
    def __init__(self, order_id: str, customer_id: str, items: List[Dict], total: float):
        self.order_id = order_id
        self.customer_id = customer_id
        self.items = items
        self.total = total

class ProcessPaymentCommand(Command):
    def __init__(self, order_id: str, payment_id: str, amount: float):
        self.order_id = order_id
        self.payment_id = payment_id
        self.amount = amount

# Queries
class GetOrderQuery(Query[Dict]):
    def __init__(self, order_id: str):
        self.order_id = order_id

class GetCustomerOrdersQuery(Query[List[Dict]]):
    def __init__(self, customer_id: str, page: int = 1, limit: int = 20):
        self.customer_id = customer_id
        self.page = page
        self.limit = limit

# Command Handlers
class CreateOrderCommandHandler(CommandHandler):
    def __init__(self, order_repository: OrderRepository, event_bus: AWSEventBus):
        self.order_repository = order_repository
        self.event_bus = event_bus
    
    async def handle(self, command: CreateOrderCommand) -> None:
        """Handle create order command"""
        try:
            # Create aggregate
            order = Order.create_order(
                command.order_id,
                command.customer_id,
                command.items,
                command.total
            )
            
            # Save aggregate (persists events)
            await self.order_repository.save(order)
            
            # Publish events to event bus
            for event in order.uncommitted_events:
                await self.event_bus.publish_event('order-events', event)
            
        except Exception as e:
            raise Exception(f"Failed to create order: {str(e)}")

# Query Handlers with Read Models
from elasticsearch import AsyncElasticsearch

class OrderReadModelRepository:
    def __init__(self, es_client: AsyncElasticsearch):
        self.es = es_client
        self.index = 'order_read_models'
    
    async def get_order(self, order_id: str) -> Optional[Dict[str, Any]]:
        """Get order read model by ID"""
        try:
            response = await self.es.get(index=self.index, id=order_id)
            return response['_source']
        except Exception:
            return None
    
    async def get_customer_orders(self, customer_id: str, page: int, limit: int) -> List[Dict[str, Any]]:
        """Get customer orders with pagination"""
        try:
            from_offset = (page - 1) * limit
            
            query = {
                'query': {
                    'term': {'customer_id': customer_id}
                },
                'sort': [{'created_at': {'order': 'desc'}}],
                'from': from_offset,
                'size': limit
            }
            
            response = await self.es.search(index=self.index, body=query)
            
            return [hit['_source'] for hit in response['hits']['hits']]
        except Exception as e:
            raise Exception(f"Failed to get customer orders: {str(e)}")
    
    async def upsert_order(self, order_data: Dict[str, Any]) -> None:
        """Upsert order read model"""
        try:
            await self.es.index(
                index=self.index,
                id=order_data['order_id'],
                body=order_data
            )
        except Exception as e:
            raise Exception(f"Failed to upsert order read model: {str(e)}")

class GetOrderQueryHandler(QueryHandler[Optional[Dict]]):
    def __init__(self, read_model_repo: OrderReadModelRepository):
        self.read_model_repo = read_model_repo
    
    async def handle(self, query: GetOrderQuery) -> Optional[Dict]:
        """Handle get order query"""
        return await self.read_model_repo.get_order(query.order_id)

# Event Projections to Read Models
class OrderProjectionHandler:
    def __init__(self, read_model_repo: OrderReadModelRepository):
        self.read_model_repo = read_model_repo
    
    async def handle_order_created(self, event: DomainEvent):
        """Project OrderCreated event to read model"""
        order_data = {
            'order_id': event.data['order_id'],
            'customer_id': event.data['customer_id'],
            'items': event.data['items'],
            'total': event.data['total'],
            'status': 'pending',
            'created_at': event.timestamp.isoformat(),
            'updated_at': event.timestamp.isoformat()
        }
        
        await self.read_model_repo.upsert_order(order_data)
    
    async def handle_payment_processed(self, event: DomainEvent):
        """Update order read model when payment is processed"""
        order_id = event.data['order_id']
        payment_status = event.data['status']
        
        # Get existing read model
        existing_order = await self.read_model_repo.get_order(order_id)
        if existing_order:
            existing_order['payment_status'] = payment_status
            existing_order['status'] = 'confirmed' if payment_status == 'success' else 'payment_failed'
            existing_order['updated_at'] = event.timestamp.isoformat()
            
            await self.read_model_repo.upsert_order(existing_order)

# Command and Query Bus
class MessageBus:
    def __init__(self):
        self.command_handlers = {}
        self.query_handlers = {}
        self.event_handlers = {}
    
    def register_command_handler(self, command_type: Type[Command], handler: CommandHandler):
        self.command_handlers[command_type] = handler
    
    def register_query_handler(self, query_type: Type[Query], handler: QueryHandler):
        self.query_handlers[query_type] = handler
    
    def register_event_handler(self, event_type: str, handler: Callable):
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    async def send_command(self, command: Command) -> None:
        """Send command to appropriate handler"""
        handler = self.command_handlers.get(type(command))
        if not handler:
            raise ValueError(f"No handler registered for command {type(command)}")
        
        await handler.handle(command)
    
    async def send_query(self, query: Query[T]) -> T:
        """Send query to appropriate handler"""
        handler = self.query_handlers.get(type(query))
        if not handler:
            raise ValueError(f"No handler registered for query {type(query)}")
        
        return await handler.handle(query)
    
    async def publish_event(self, event: DomainEvent) -> None:
        """Publish event to all registered handlers"""
        handlers = self.event_handlers.get(event.event_type, [])
        
        # Execute handlers concurrently
        tasks = [handler(event) for handler in handlers]
        await asyncio.gather(*tasks, return_exceptions=True)
```

## Production Deployment Considerations

### Event Schema Management

```python
# Event Schema Registry
import json
from typing import Dict, Any
from jsonschema import validate, ValidationError

class EventSchemaRegistry:
    def __init__(self):
        self.schemas = {}
        self._initialize_schemas()
    
    def _initialize_schemas(self):
        """Initialize event schemas"""
        self.schemas['UserRegistered'] = {
            "type": "object",
            "properties": {
                "user_id": {"type": "string"},
                "email": {"type": "string", "format": "email"},
                "name": {"type": "string", "minLength": 1},
                "registration_source": {"type": "string"}
            },
            "required": ["user_id", "email", "name"],
            "additionalProperties": False
        }
        
        self.schemas['OrderCreated'] = {
            "type": "object",
            "properties": {
                "order_id": {"type": "string"},
                "customer_id": {"type": "string"},
                "items": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "product_id": {"type": "string"},
                            "quantity": {"type": "integer", "minimum": 1},
                            "price": {"type": "number", "minimum": 0}
                        },
                        "required": ["product_id", "quantity", "price"]
                    }
                },
                "total": {"type": "number", "minimum": 0}
            },
            "required": ["order_id", "customer_id", "items", "total"],
            "additionalProperties": False
        }
    
    def validate_event(self, event: DomainEvent) -> bool:
        """Validate event against schema"""
        schema = self.schemas.get(event.event_type)
        if not schema:
            raise ValueError(f"No schema found for event type {event.event_type}")
        
        try:
            validate(event.data, schema)
            return True
        except ValidationError as e:
            raise ValueError(f"Event validation failed: {str(e)}")
    
    def register_schema(self, event_type: str, schema: Dict[str, Any]):
        """Register new event schema"""
        self.schemas[event_type] = schema
    
    def evolve_schema(self, event_type: str, new_schema: Dict[str, Any], version: int):
        """Handle schema evolution"""
        version_key = f"{event_type}_v{version}"
        self.schemas[version_key] = new_schema
```

### Monitoring and Alerting

```yaml
# Prometheus monitoring for event-driven systems
apiVersion: v1
kind: ConfigMap
metadata:
  name: event-monitoring-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    
    scrape_configs:
    - job_name: 'event-producers'
      static_configs:
      - targets: ['order-service:8080', 'user-service:8080']
      metrics_path: '/metrics'
      scrape_interval: 10s
    
    - job_name: 'event-consumers'
      static_configs:
      - targets: ['email-service:8080', 'analytics-service:8080']
      metrics_path: '/metrics'
      scrape_interval: 10s
    
    - job_name: 'message-brokers'
      static_configs:
      - targets: ['kafka-exporter:9308']
      scrape_interval: 30s
    
    rule_files:
    - '/etc/prometheus/rules/*.yml'
    
    alerting:
      alertmanagers:
      - static_configs:
        - targets: ['alertmanager:9093']
  
  event-rules.yml: |
    groups:
    - name: event_processing
      rules:
      - alert: HighEventProcessingLatency
        expr: histogram_quantile(0.95, rate(event_processing_duration_seconds_bucket[5m])) > 2
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High event processing latency detected"
          description: "95th percentile event processing latency is {{ $value }} seconds"
      
      - alert: EventProcessingErrors
        expr: rate(event_processing_errors_total[5m]) > 0.1
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "High error rate in event processing"
          description: "Error rate is {{ $value }} errors per second"
      
      - alert: DeadLetterQueueBacklog
        expr: aws_sqs_approximate_number_of_messages{queue_name=~".*-dlq"} > 100
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Dead letter queue has significant backlog"
          description: "DLQ {{ $labels.queue_name }} has {{ $value }} messages"
```

## Conclusion

Event-driven architecture in the cloud enables building highly scalable, resilient, and maintainable distributed systems. Key success factors include:

1. **Proper Event Design**: Use domain events that represent meaningful business occurrences
2. **Schema Evolution**: Plan for event schema changes and backward compatibility  
3. **Error Handling**: Implement comprehensive error handling with dead letter queues
4. **Monitoring**: Track event flow, processing latency, and error rates
5. **Testing**: Test event handlers in isolation and end-to-end scenarios
6. **Consistency**: Choose appropriate consistency models (eventual vs. strong)

The cloud provides excellent infrastructure for event-driven systems through managed message brokers, event streaming platforms, and serverless compute options. By combining these with solid architectural patterns like event sourcing, CQRS, and saga patterns, you can build systems that scale to handle millions of events while maintaining consistency and reliability.

Remember to start simple and evolve your event-driven architecture as your system grows in complexity and scale. The patterns and implementations shown here provide a solid foundation for building production-ready event-driven systems in the cloud.